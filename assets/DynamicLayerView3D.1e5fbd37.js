import{bI as b,bJ as R,bK as q,bL as W,bM as j,bN as f,a8 as H,k,p as B,bO as J,w as A,H as Y,t as G,bP as Z,b3 as D,aB as K,am as L,bQ as Q,bR as X,bS as ee,bT as te,bU as P,b9 as I,r as N,bV as M,bW as ae,bX as U,a3 as ie,bY as _,a4 as z,bZ as re,b_ as se,b$ as ne,aJ as oe,e as w,d as x,n as le}from"./index.a8738f47.js";import{n as he}from"./LayerView3D.8dc7c2ab.js";import{l as de}from"./projectExtentUtils.4c0871bc.js";import{m as ce}from"./ImageMaterial.c05046f5.js";import{u as ue}from"./LayerView.bc32b3eb.js";import{i as me}from"./RefreshableLayerView.06f790ae.js";function ge(e,t,a){const r=b(e)/R(e),i={width:a,height:a};return r>1.0001?i.height=a/r:r<.9999&&(i.width=a*r),i.width=Math.round(i.width/(b(e)/b(t))),i.height=Math.round(i.height/(R(e)/R(t))),i}function V(e){return q.createSquareGeometry([[e[0],e[1],-1],[e[2],e[1],-1],[e[2],e[3],-1],[e[0],e[3],-1]])}function fe(e,t){if(!W(e,t))return V(t);const a=[e[1]-t[1],Math.min(e[3],t[3])-Math.max(e[1],t[1]),t[3]-e[3],123456],r=[e[0]-t[0],Math.min(e[2],t[2])-Math.max(e[0],t[0]),t[2]-e[2],123456],i=t[2]-t[0],o=t[3]-t[1],s=r[0]>0&&r[2]>0?3:2,n=a[0]>0&&a[2]>0?3:2,d=(n+1)*(s+1),l=new Float64Array(3*d),c=new Float32Array(2*d),h=new Uint32Array(6*(n*s-1));let v=0,S=0,T=0,u=0,g=0;for(let p=0;p<4;p++){const $=a[p];if($<=0)continue;let E=0;for(let y=0;y<4;y++){const O=r[y];O<=0||(l[S++]=t[0]+E,l[S++]=t[1]+v,l[S++]=-1,c[T++]=E/i,c[T++]=v/o,y<3&&p<3&&(y!==1||p!==1)&&(h[g++]=u,h[g++]=u+1,h[g++]=u+s+1,h[g++]=u+1,h[g++]=u+s+2,h[g++]=u+s+1),u++,E+=O)}v+=$}const F=new Uint32Array(h.length);return new j([[f.POSITION,{size:3,data:l,exclusive:!0}],[f.NORMAL,{size:3,data:pe,exclusive:!0}],[f.UV0,{size:2,data:c,exclusive:!0}]],[[f.POSITION,h],[f.NORMAL,F],[f.UV0,h]])}const pe=[0,0,1],C=H.getLogger("esri.views.3d.layers.DynamicLayerView3D");let m=class extends me(he(ue)){constructor(){super(...arguments),this.drapeSourceType=k.RasterImage,this.updatePolicy=B.SYNC,this.fullExtentInLocalViewSpatialReference=null,this.maximumDataResolution=null,this._images=new Array,this._extents=new Array,this._overlays=new Array,this.updateWhenStationary=!0,this._drapeSourceRenderer=null,this.refreshDebounced=J(async e=>{this.destroyed||await this._doRefresh(e).catch(t=>{A(t)||H.getLogger(this.declaredClass).error(t)})},2e3)}initialize(){this._drapeSourceRenderer=this.view.basemapTerrain.overlayManager.registerGeometryDrapeSource(this),this.handles.add(Y(()=>this.view.basemapTerrain.overlayManager.unregisterDrapeSource(this))),this.addResolvingPromise(de(this).then(e=>this._set("fullExtentInLocalViewSpatialReference",e))),this.updatingHandles.add(()=>this.suspended,()=>this._suspendedChangeHandler()),this.handles.add(this.view.resourceController.scheduler.registerIdleStateCallbacks(()=>{this._isScaleRangeActive()&&this.notifyChange("suspended")},()=>{})),this._isScaleRangeLayer()&&this.updatingHandles.add(()=>this.layer.effectiveScaleRange,()=>this.notifyChange("suspended"))}destroy(){this.clear()}setDrapingExtent(e,t){this._spatialReference=t,e.forEach(a=>{this._overlays[a.index]=a,this._updateImageExtent(a)})}_updateImageExtent(e){const t=this._clippedExtent(e.extent,ye);if(G(t))return;const a=ge(e.extent,t,e.resolution);let r=e.pixelRatio*this.view.state.pixelRatio;if("imageMaxWidth"in this.layer||"imageMaxHeight"in this.layer){const o=this.layer.imageMaxWidth,s=this.layer.imageMaxHeight;if(a.width>o){const n=o/a.width;a.height=Math.floor(a.height*n),a.width=o,r*=n}if(a.height>s){const n=s/a.height;a.width=Math.floor(a.width*n),a.height=s,r*=n}}const i=this._extents[e.index];i&&Z(i.extent,t)&&this._imageSizeEquals(t,i.imageSize,a)||(this._extents[e.index]={extent:D(t),imageSize:a,pixelRatio:r},this.suspended||this._fetch(e.index).catch(o=>{A(o)||C.error(o)}))}clear(){for(let e=0;e<this._images.length;e++)this._clearImage(e)}async doRefresh(){return this._doRefresh()}async _doRefresh(e){if(this.suspended)return;const t=[];for(let a=0;a<this._extents.length;a++)this._extents[a]&&t.push(this._fetch(a,e));await K(t)}canResume(){if(!super.canResume())return!1;const e=this.layer;if(this._isScaleRangeActive()){const{minScale:t,maxScale:a}=e.effectiveScaleRange,r=this.view.scale;if(r<a||t>0&&r>t)return!1}return!0}isUpdating(){return this._images.some(e=>!!e.loadingPromise)}async processResult(e,t,a){(t instanceof HTMLImageElement||t instanceof HTMLCanvasElement)&&(e.image=t)}findExtentInfoAt(e){for(const t of this._extents){const a=t.extent;if(new L(a[0],a[1],a[2],a[3],this._spatialReference).contains(e))return t}return null}getFetchOptions(){}async redraw(e,t){await Q(this._images,async(a,r)=>{a&&(await e(a,t),await this._createStageObjects(r,a.image,t))})}_imageSizeEquals(e,t,a){if(!this.maximumDataResolution)return!1;const r=b(e)/this.maximumDataResolution.x,i=R(e)/this.maximumDataResolution.y,o=r/t.width,s=i/t.height,n=r/a.width,d=i/a.height,l=Math.abs(o-n),c=Math.abs(s-d),h=X.TESTS_DISABLE_OPTIMIZATIONS?0:1.5;return l<=h&&c<=h}async _fetch(e,t){if(this.suspended)return;const a=this._extents[e],r=a.extent;this._images[e]||(this._images[e]={texture:null,material:null,renderGeometry:null,loadingPromise:null,loadingAbortController:null,image:null,pixelData:null,renderExtent:D(r)});const i=this._images[e];i.loadingAbortController&&(i.loadingAbortController.abort(),i.loadingAbortController=null);const o=new L(r[0],r[1],r[2],r[3],this._spatialReference);if(o.width===0||o.height===0)return void this._clearImage(e);const s=new AbortController;i.loadingAbortController=s,ee(t,()=>s.abort());const n=s.signal,d=this._waitFetchReady(n).then(async()=>{const l={requestAsImageElement:!0,pixelRatio:this._overlays[e].pixelRatio,...this.getFetchOptions(),signal:n},{height:c,width:h}=a.imageSize;return this.layer.fetchImage(o,h,c,l)}).then(l=>{if(te(n))throw C.warnOnce("A call to fetchImage resolved even though the request was aborted. fetchImage should not resolve if options.signal.aborted is true."),P();return this.processResult(i,l)}).then(()=>{I(i.renderExtent,r)}).finally(()=>{d===i.loadingPromise&&(i.loadingPromise=null,i.loadingAbortController=null)});i.loadingPromise=d,this.notifyChange("updating"),await d.then(async()=>{if(n.aborted)throw P();await this._createStageObjects(e,i.image,n),this.notifyChange("updating")}).catch(l=>{throw l&&!A(l)&&C.error(l),this.notifyChange("updating"),l})}_clearImage(e){const t=this._images[e];if(t){N(t.renderGeometry)&&(this._drapeSourceRenderer.removeGeometries([t.renderGeometry],M.Geometry.UPDATE),t.renderGeometry=null);const a=this.view._stage;a.remove(t.texture),t.texture=null,a.remove(t.material),t.material=null,t.loadingAbortController&&(t.loadingAbortController.abort(),t.loadingAbortController=null),t.loadingPromise=null,t.image=null,t.pixelData=null}}async _createStageObjects(e,t,a){const r=this.view._stage,i=this._images[e],o=()=>{r.remove(i.texture),i.texture=null,N(i.renderGeometry)&&(this._drapeSourceRenderer.removeGeometries([i.renderGeometry],M.Geometry.UPDATE),i.renderGeometry=null)};if(t){const s=new ae(t,{width:t.width,height:t.height,preMultiplyAlpha:!0,wrap:{s:U.CLAMP_TO_EDGE,t:U.CLAMP_TO_EDGE}});let n;if(await ie(this._images[e===_.INNER?_.OUTER:_.INNER].loadingPromise),z(a),e===_.INNER)n=V(i.renderExtent);else{const d=this._images[0].renderExtent;if(!d)return void o();n=fe(d,i.renderExtent)}o(),r.add(s),await r.loadImmediate(s),i.texture=s,G(i.material)?(i.material=new ce({transparent:!0,textureId:s.id}),r.add(i.material)):i.material.setParameters({textureId:s.id}),i.renderGeometry=new re(n,i.material),i.renderGeometry.origin=this._overlays[e].renderLocalOrigin,this._drapeSourceRenderer.addGeometries([i.renderGeometry],M.Geometry.UPDATE)}else o(),r.remove(i.material),i.material=null}_isScaleRangeLayer(){return"effectiveScaleRange"in this.layer}_isScaleRangeActive(){const e=this.layer;if(!this._isScaleRangeLayer())return!1;const{minScale:t,maxScale:a}=e.effectiveScaleRange;return se(t,a)}_clippedExtent(e,t){if(this.view.viewingMode!=="local")return I(t,e);const a=this.view.basemapTerrain;return a.ready?ne(e,a.extent,t):I(t,e)}_suspendedChangeHandler(){this.suspended?this.clear():this.refreshDebounced()}async _waitFetchReady(e){await oe(()=>this.view.stationary,e),z(e)}};w([x()],m.prototype,"layer",void 0),w([x()],m.prototype,"suspended",void 0),w([x({readOnly:!0})],m.prototype,"fullExtentInLocalViewSpatialReference",void 0),w([x()],m.prototype,"updating",void 0),m=w([le("esri.views.3d.layers.DynamicLayerView3D")],m);const Se=m,ye=D();export{Se as q};
