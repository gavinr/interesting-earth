import{e1 as s,aq as h,b7 as r}from"./index-4b03b1b0.js";class f{constructor(e,i=0,l=e.lods[e.lods.length-1].level){this.tileInfo=e,this.minLOD=i,this.maxLOD=l,e.lodAt(i)||(this.minLOD=e.lods[0].level),e.lodAt(l)||(this.maxLOD=e.lods[e.lods.length-1].level)}get effectiveMinLOD(){return this.minLOD??this.tileInfo.lods[0].level}get effectiveMaxLOD(){return this.maxLOD??this.tileInfo.lods[this.tileInfo.lods.length-1].level}getAvailability(e,i,l){var a;const t=(a=this.tileInfo)==null?void 0:a.lodAt(e);return!t||e<this.minLOD||e>this.maxLOD?"unavailable":t.cols&&t.rows?l>=t.cols[0]&&l<=t.cols[1]&&i>=t.rows[0]&&i<=t.rows[1]?"unknown":"unavailable":"unknown"}async fetchAvailability(e,i,l,t){await s(t);const a=this.getAvailability(e,i,l);if(a==="unavailable")throw new h("tile-map:tile-unavailable","Tile is not available",{level:e,row:i,col:l});return a}async fetchAvailabilityUpsample(e,i,l,t,a){await s(a),t.level=e,t.row=i,t.col=l;const n=this.tileInfo;return n.updateTileInfo(t),this.fetchAvailability(e,i,l,a).catch(o=>{if(r(o))throw o;if(n.upsampleTile(t))return this.fetchAvailabilityUpsample(t.level,t.row,t.col,t,a);throw o})}}export{f as e};
